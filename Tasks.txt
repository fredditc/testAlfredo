
===============================================================================================================================================
I am a java tech lead with four years of experience. I've worked with clients in the finance and automatic industries using agile methodologies and 
back-end frameworks such as spring boot, maven, JPA, and docker.
In my last project, I was a team with three resources.

In my last project in the automatic industry, industry 4.0 was implemented, which is basically access to data in real time with the help of interconnectivity through the Internet of Things.
The project was based on the data generated by the production line, there was an app in react native that showed the status of the line in 
real-time and there was a web page where stadistics of its indicators were generated based on a required date range.
===============================================================================================================================================


About experiencia
Hasta el momento he tenido 3 trabajos de los cuales los primeros dos han sido en el sector financiero, en los cuales desarrollé el skill de la lectura y compresión de algoritmos matemáticos internos para los diferentes procesos y aprendí las tecnologías de spring framework, DWR y Ext JS.

-Last work experiencia
En mi último trabajo colaboré en un proyecto para el sector automotriz donde se esta implementando la industria 4.0, es decir, a la empresa se le genera estadisticas en tiempo real y resultados de producción en base a los targets internos. Trabajé muy poco con front end con tecnologías como React y Reac Native y para backend eran servicios rest con spring boot y docker.

—Desglosar más respecto a las actividades.


Creación de un proyecto



Lambda
Optional 
Stream diferencia
 collections repasar
===============================================================================================================================================
Checked Exception:
Son excepciones que el compilador fuerza a que sean capturadas y no se pueden ignorar (En un bloque try-catch)  

Unchecked: 
Heredan de RuntimeException pero estas no se capturan ni se pueden lanzar debido a que se consideran errores en la programación (ArrayIndexoutOfBounds, NullpointerException, ArithmeticException)
===============================================================================================================================================

Inyección de dependencias
It is a technique where an object is provided with the dependencies it needs (It is a way to implement inversion of control)

Inversión of control
It is a principle where there is an object or a program that gives control to someone else (framework)
Para implementar esto se pueden ocupar patrones de diseño.
In a JUnit test class, which has 3 methods and you put an annotation on them, the programmer doesn't know when that method will
be executed since that is controlled by the framework.
The container will create the objects, connect them, configure them, and manage their entire lifecycle from creation to destruction.

===============================================================================================================================================

Inititilizar (Proyecto)
through web interface(start.spring.io): in the web page you can decide if you use gradle or mave, java or Groovy, dependencies and the version of spring boot.
through Spring Tool Suite: only you can select a new start spring boot project
through Spring Boot CLI: You can use different commands for initilize spring boot project

===============================================================================================================================================

@profile
spring.profiles.active=test with diferent configuration files: application-{mode}.properties
@Profile(“mode”) use when you need production data and you can configure different repository beans in production mode.

===============================================================================================================================================
JPA : Specification of how objects should be mapped to the relational database.
@Entity: Indicates that it will be a database entity
@Table: It is to indicate the name of the database table if it changes with the name of the class.
@Column: Indicates the database field and if it has the value it is because the name of the field in the database has changed. @Column(name = “asa”)
@GeneratedValue: Refers to the increment of the primary key 
@Id: Indicates that it will be the primary key of the table
@Transient: It means that it is not a relation to a database field and ORM ignores this attribute.
@Temporal: It is to indicate the precision of time dates @Temporal(TemporalType.TimeStamp)
@OneToMany
@ManyToOne
@ManyToMany
@Query (uso de Spring Data JPA)

Hibernate: Is the implementation of JPA. Allow execute different operations for database like (query, insert or delete).

===============================================================================================================================================

Objeto - City and Country

Example 6
—Primer: Listar puros de EUA
—Segundo ejercicio: Pais nulo optional

-Operaciones intermedias y terminales.
-Donde hay collection y el Stream.

===============================================================================================================================================
Bean Factory:
App context:
===============================================================================================================================================
Cobertura

Test driven develpment


Cómo revisas tu código?
Zonar Q

https://www.grammarly.com/signup?afterSurvey=recommend
===============================================================================================================================================
https://yalantis.com/blog/how-to-create-a-restful-api/
URIs (Uniform Resource Identifiers): Is a sequence of symbol that identifiers a resource and often allows developers to access representations of that resource.
URL(Uniform Resource Locator)
URN(Uniform Resource Name)
URI: https://examplesite.com/page/example
-Method: https
-Domain: examplesite.com
-urn: examplesite.com/page/example
-path: page
-resource: example
-url: https://examplesite.com/page
===============================================================================================================================================
End Points: Endpoints specify where resources are located and how they can be accessed by third-party software. 
Usually, they’re accessed via a URI to which HTTP requests are sent and from which the response is expected
-GET – retrieve resources from the server using a given URI
-POST – send resources to the server
-PUT – update existing information with uploaded content
-DELETE – remove all existing resources   
===============================================================================================================================================
HTTP Status Code
HTTP status codes, sometimes called internet or browser error codes, are standard response codes sent by a web server that identify 
whether an operation performed was successful or why pages or resources aren’t loading properly.

2XX (Success)
-200: OK. This is the most commonly used response to inform that a request has succeeded.
-201: Object created. The server has fulfilled the request and created a new resource.
-204: No content. The server has successfully fulfilled the request and the API declines to send back any status message or representation in the response message body.
-206: Partial content. The server has fulfilled the request and the body contains the requested ranges of data, as described in the Range header of the request.

3XX (Redirection)
-304: Not modified. The client has requested cached data and there’s no need to transfer it again.

4XX (Client Error)
-400: Bad request. The server couldn’t understand the request because of invalid syntax (e.g. invalid request message framing or deceptive request routing).
-401: Unauthorized. The user or the system is trying to operate on a protected resource without providing proper authentication credentials.
-403: Forbidden. The server understands the request but refuses to authorize it.
-404: Not found. The origin server can’t find a current representation for the target resource or is not willing to disclose that one exists.

5XX (Server Error)
-500: Internal server error. Ideally, you’re not going to be explicitly returning this, but if something unexpectedly breaks, this is what your user is going to receive.
-503: Service unavailable. The server is currently unable to handle the request due to a temporary overload or scheduled maintenance.
===============================================================================================================================================
https://www.interviewbit.com/junit-interview-questions/
What is Unit Testing?: is a software testing strategy that tests single entities like methods or classes at a time. This helps to ensure that the product quality is met as per the business requirements
Check out code from repository -> make changes -> execute unit test -> Fix defects and re-execute test -> code review -> check in code into repository

6. What are some of the important annotations provided by JUnit?: 
@Test: This annotation over a public method of void return type can be run as a test case. This is a replacement of the org.junit.TestCase annotation.
@Before: This is used when we want to execute the preconditions or any initialisation based statements before running every test case.
@BeforeClass: This is used when we want to execute statements before all test cases. The statements may include test connections, common setup initialisation etc.
@After: This is used when we want to execute statements after each test case. The statements can be resetting the variables, deleting extra memory used etc.
@AfterClass: This is used when certain statements are required to be executed after all the test cases of the class are run. Releasing resource connections post-execution of test cases is one such example.
@Ignores: This is used when some statements are required to be ignored during the execution of test cases.
@Test(timeout=x): This is used when some timeout during the execution of test cases is to be set. The value of x is an integer that represents the time within which the tests have to be completed.
@Test(expected=NullPointerException.class): This is used when some exception thrown by the target method needs to be asserted.

7. 12. What is mocking and stubbing?.
Stub: are objects that are configured to return values ​​that conform to what the unit test wants to test, so it is used to check the state of objects (check the state of objects) Estado
Mock: are objects that are used to test that calls to other methods are made correctly, for example, to a web API (check object behavior) Comportamiento


8. 13. What are the JUnit Assert Methods?:
Assert methods are utility methods that support assert conditions in test cases

9. What are the best practices for writing Unit Test Cases?
*For every method, we need to have at least two unit test cases - a positive test case and a negative test case.
*If there are sub-requirements for a requirement, then those sub-requirements should have their own positive and negative test cases.
*Each test case should be independent of other test cases. If we make a chain of unit test cases, then it would not be possible for finding the root cause of the test case failures.
*Mock all the external services that are used by the modules under test. This is necessary because we do not want to unnecessarily debug our modules under test due to the failures of the external systems.
*Configuration settings need not be tested as they won’t be part of any unit code. Even if we want to inspect the configuration, then test whether the loading code is working or not.
*The unit test cases should be named consistently and clearly. The names of the test cases should be dependent on the operations that the test case would test.

10. What is the purpose of @Before and @After annotations in JUnit 4?
These are the annotations present in JUnit 4. Methods annotated with @Before will be called and run before the execution of each test case. 
Methods annotated with @After will be called and executed after the execution of each test case.
===============================================================================================================================================
https://www.baeldung.com/java-8-interview-questions

Lambda Expressions − a new language feature allowing us to treat actions as objects
Method References − enable us to define Lambda Expressions by referring to methods directly using their names
Optional − special wrapper class used for expressing optionality
Functional Interface – an interface with maximum one abstract method; implementation can be provided using a Lambda Expression
Default methods − give us the ability to add full implementations in interfaces besides abstract methods
Nashorn, JavaScript Engine − Java-based engine for executing and evaluating JavaScript code
Stream API − a special iterator class that allows us to process collections of objects in a functional manner
Date API − an improved, immutable JodaTime-inspired Date API

Q1. What Is a Method Reference?
Is a Java construct that can be used for referencing a method without invoking it. It's used for treating methods as Lambda Expressions. 
They only work as syntactic sugar to reduce the verbosity of some lambdas
A method reference can be identified by a double colon separating a class or object name, and the name of the method

Q1. What Is Optional? How Can It Be Used?
Is a class that encapsulates an optional value, i.e. a value that is either there or not. 
It's a wrapper around an object, and we can think of it as a container of zero or one element.
Optional has a special Optional.empty() value instead of wrapped null. Thus it can be used instead of a nullable value to get rid of NullPointerException in many cases.

What Is a Functional Interface? What Are the Rules of Defining a Functional Interface?
Function – it takes one argument and returns a result
Consumer – it takes one argument and returns no result (represents a side effect)
Supplier – it takes no arguments and returns a result
Predicate – it takes one argument and returns a boolean
BiFunction – it takes two arguments and returns a result
BinaryOperator – it is similar to a BiFunction, taking two arguments and returning a result. The two arguments and the result are all of the same types.
UnaryOperator – it is similar to a Function, taking a single argument and returning a result of the same type

A functional interface is an interface with one single abstract method (default methods do not count), no more, no less.
Where an instance of such an interface is required, a Lambda Expression can be used instead. More formally put:
*Functional interfaces provide target types for lambda expressions and method references.

The arguments and return type of such an expression directly match those of the single abstract method.

Explain the Syntax and Characteristics of a Lambda Expression
a lambda expression is a function that we can reference and pass around as an object.
One of their main uses is to define inline implementations of functional interfaces

params -> expressions

Any lambda expression has the following characteristics:

Optional type declaration – when declaring the parameters on the left-hand side of the lambda, we don't need to declare their types as the compiler can infer them from their values. So int param -> … and param ->… are all valid
Optional parentheses – when only a single parameter is declared, we don't need to place it in parentheses. This means param -> … and (param) -> … are all valid, but when more than one parameter is declared, parentheses are required
Optional curly braces – when the expressions part only has a single statement, there is no need for curly braces. This means that param – > statement and param – > {statement;} are all valid, but curly braces are required when there is more than one statement
Optional return statement – when the expression returns a value and it is wrapped inside curly braces, then we don't need a return statement. That means (a, b) – > {return a+b;} and (a, b) – > {a+b;} are both valid


What Is a Stream? How Does It Different From a Collection?
a stream is an iterator whose role is to accept a set of actions to apply on each of the elements it contains.
They were designed to make collection processing simple and concise. Contrary to the collections, 
the logic of iteration is implemented inside the stream (map)
Another important distinction from collections is that streams are inherently lazily loaded and processed.

What Is the Difference Between Intermediate and Terminal Operations?
Intermediate operations are those operations that return Stream itself, allowing for further operations on a stream.
map, filter y flatMap

terminal operations terminate the pipeline and initiate stream processing.
The stream is passed through all intermediate operations during terminal operation call. 

What Is the Difference Between Map and flatMap Stream Operation
Map: map() returns the same number of elements as the input Stream since it is simply a projection of the input elements
FlatMap: FlatMap is a function that takes an input and returns multiple outputs for that input

===============================================================================================================================================

https://www.edureka.co/blog/interview-questions/java-collections-interview-questions/
2. What do you understand by Collection Framework in Java?
3. . List down the primary interfaces provided by Java Collections Framework?
4. What is the need for overriding equals() method in Java?
5. 31. Differentiate between Collection and Collections.
6. 35. Differentiate between Comparable and Comparator.
7. 43. Differentiate between HashMap and HashTable.
8. 44. Differentiate between HashSet and HashMap.
9. 8. Differentiate between HashMap and TreeMap.

===============================================================================================================================================
How to Create a Really Great RESTful API: Developer’s Chec.klist
A complete guide for developers who want to create a RESTful API. Discover what you should consider and what challenges you can face during development.

https://www.geeksforgeeks.org/difference-between-and-equals-method-in-java/
Difference between comparing String using == and .equals() method in Java - GeeksforGeeks
A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interv...


https://www.baeldung.com/spring-boot-start (Para la semana)

https://spring.io/guides/gs/spring-boot/

Cobertura: Coverage lets us know how much code we are actually testing with our test.
Checkstyle:It is to evaluate the code that is being made.
And it allows analysis of the flow of control and data, coding rules, security rules or variable analysis.
SonarQube:It helps to detect many problems, facilitating their solution quickly as soon as it appears, thus keeping the code clean, simple and easy to read.


-stringbuffer and stringbuilder:
StringBuilder: 16 caracters default (Size and content can be changed, mutables) Methods are not synchronized or thread-safe
(more efficiente when you donde use thread.)
StringBuffer: methods are synchronized, allows working with multiple execution threads (threads).

-synchornize:
It ensures that there are not two threads executing the same method. If there are multiple threads trying to execute the same
method at the same time, one will achieve its execution and the others will have to wait for it to finish to get their turn.

-deadlock
DeadLock:
 is when two or more threads block each other, waiting for each other, without progressing any of them
Mutual exclusion: Mutual exclusion algorithms are used in concurrent programming to prevent more than one process from entering at a time.

-mutable and inmutable:
Mutable:
means that state or data can be changed after it's created.
everything(except for strings and all the wrapper classes) is mutable by default.

Inmutable:
It means we can't change anything to the existing objects.
Cualquier operacion de modificacion produce una instancia nueva. Buena para compartir entre hilos de ejecuciiones diferentes.
String objectes are inmutable.

Final:
apply constraints to a class, to a method or field of a class, or to a variable.
Final classes: can't use inheritance
Final methods or fields: cannot be overridden
Variables: assign a value when declared (way to declare constant)

Finalize: it is a method that can be overridden and when java detects that there are no more references to the object, it releases resources

Finally:
In a try-catch structure there is a finally block that allows the always included code to be executed if there is an exception

Throwable 
Error vs Exception

When the error occurs and cannot be recovered and they are not errors because of the code that was written.
(VirtualMachineError -> OutOfMemoryError) 

Exception
IOException (Checked) -> FileNotFoundExceptiom
RunTimeException (unchecked) -> NullPointer Arithmetic 

To create your own exceptions you must create the class and extend Exception and in the constructor invoke super(message)

Access control: allows the compiler to interpret what is visible or usable outside the class and what is not through access modifiers:
Públic
Protected 
Prívate 
default 

Spring vs spring boot
Spring Boot is a variation of Spring that comes with the configuration, which previously had to be done manually,
making development with Spring much easier, allowing the programmer not to have to configure anything, just worry about the business logic.

*tipos de inyeccion de dependencias
-Contructor
-Setter
-and anottations

Inyeccion de dependencias (DI): it is a design pattern that serves to “inject” components to the classes that we have implemented. 
Those components are contracts that our classes need in order to function.

IOC: (delegating responsibility) The purpose is due to the need to want to control its execution flow, automatically and transparently,to give control of that 
flow to an “external agent”, normally a framework

beanFactory: is a contairne that load beans on-demand and its lifecycle start when you get the specific bean

appContext: is a container that loads all beans at startup. BeanFactory is lightweight as compared to ApplicationContext.

SobreCarga:
allows you to declare methods that are called the same but receive different parameters

SobreEscritura:
a class can re-define the methods of its parent class, in this way it can create new methods with the same name of its superClass

2 maneras de crear threads

Primera manera:
creates a new class MyThread that extends the Thread class and overrides the Thread.run() method with its own implementation. 
The run() method is where all the work of the class will be done.

Segunda manera:
You can create a new class that implements Runnable interface and overrides the method run.

desing patterns

README -> priridad baja
patrones de diseño - definicion (minimo 3 y saber de que se trata)


Que es un patron de diseño:
 These are templates that identify system problems and provide appropriate solutions to general problems.

-Creational patterns:
	*Singleton:
	*Prototype:

-Structural patterns:
	*Adapter:
	*Bridge:

-Behavior patterns:
	*State:
	*Interpreter:
-----------------------------------------------------------
README
La historia de LÉAME
Las expectativas generales de un archivo README
Las secciones e inspiraciones habituales
Referencias y otros recursos
Herramientas útiles
Créditos
Contribuir


Diferencia entre copy y add (Investigar)
HQL (Eager y lazy)
-----------------------------------------------------------


inbursa 


https://github.com/dotnet-architecture/eShopOnContainers

diferencia de clase abstracta

crear proyecto springboot
crear interfaz Employee -> método doJob 
clase abstracta militar implements Employee
(cabo, soldado, general)
crear persona 

en main charly en el doJob mostrar el rango

-----------------------------------------------------------


Autehticate and Authorization 

Basic Authentication:
Username and password are passed in a HTTP header.
OAuth 2.0 -> Delegate authorization
OpenID Connect -> Json web token
Oauth "flows" -> Interaction between client app, authorization server and microservice.

JWT: information about something that allow for authenticate in the service.

Authorization based on ROle:
-Get is public 
-put or create is necessary to log in.

Authorization based on Data:
-Check the token if not is valid is no authorization. If the token is valid check that the user 
have the correct role for do the operation (put, add, or modify).